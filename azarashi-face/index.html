<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mochi Seal 3D Interaction</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* 空の色 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        #ui-layer {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .instruction {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            font-size: 14px;
            margin: 0 5px;
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>
<div id="ui-layer">
    <div class="instruction">顔・鼻・ベロ: ドラッグでもちもち</div>
    <div class="instruction">目: クリック/タッチで閉じる（ドラッグ不可）</div>
</div>

<!-- Three.js Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/**
 * 設定パラメータ
 */
const CONFIG = {
    color: {
        body: new THREE.Color(0x8FA4B5),     // アザラシのグレーブルー
        eyeWhite: 0xFFFFFF,
        pupil: 0x111111,
        nose: 0x222222,
        tongue: 0xFF8888
    },
    physics: {
        springStrength: 0.08, 
        damping: 0.85,        
        radius: 4.5,          
        maxDeformation: 3.0   
    },
    interaction: {
        spinThreshold: 5.0,   
        friction: 0.97,       
        recoilFactor: 1.5,    
        recoverySpeed: 0.05,
        blinkSpeed: 0.3       // まばたきの速さ
    }
};

// グローバル変数
let scene, camera, renderer;
let sealGroup, bodyMesh, snoutGroup;

// 目の管理用オブジェクト
let eyes = { 
    left: { group: null, eyelid: null, pupil: null }, 
    right: { group: null, eyelid: null, pupil: null } 
};

let tongue;
let originalPositions = [];
let velocities = [];

// パーツ追従用
let faceCenterIndices = []; 
let partsInitialPos = {
    eyesLeft: new THREE.Vector3(),
    eyesRight: new THREE.Vector3(),
    snout: new THREE.Vector3(),
    tongue: new THREE.Vector3() 
};

// インタラクション状態
let isDraggingFace = false;
let isDraggingTongue = false; 
let isHoldingBg = false;
let isTouchingEye = false; 

let dragPoint = new THREE.Vector3(); 
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();

let lastMousePos = new THREE.Vector2();
let dragVelocity = new THREE.Vector2();

// 回転制御
let spinVelocity = new THREE.Vector3(0, 0, 0); 
let isSpinning = false;

// アニメーション状態
let tongueAnimState = 0; 
let tongueTipPos = new THREE.Vector3();      
let tongueTipVelocity = new THREE.Vector3(); 
const TONGUE_BASE_LEN = 0.44; 

// まばたき制御 (0: 開, 1: 閉)
let blinkState = { left: 0, right: 0 };
let targetBlinkState = { left: 0, right: 0 };

/**
 * 初期化処理
 */
function init() {
    const container = document.getElementById('canvas-container');

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 8, 20);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 8.5); 

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(5, 8, 7);
    dirLight.castShadow = true;
    dirLight.shadow.bias = -0.001;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    const backLight = new THREE.DirectionalLight(0xffffff, 0.4);
    backLight.position.set(-5, 2, -5);
    scene.add(backLight);

    createSeal();

    window.addEventListener('resize', onWindowResize);
    
    const canvas = renderer.domElement;
    canvas.addEventListener('pointerdown', onPointerDown);
    canvas.addEventListener('pointermove', onPointerMove);
    canvas.addEventListener('pointerup', onPointerUp);
    canvas.addEventListener('pointerleave', onPointerUp);

    animate();
}

/**
 * アザラシのモデル生成
 */
function createSeal() {
    sealGroup = new THREE.Group();
    scene.add(sealGroup);

    // 1. 体
    const bodyGeo = new THREE.SphereGeometry(2.5, 128, 128);
    const bodyMat = new THREE.MeshStandardMaterial({
        color: CONFIG.color.body,
        roughness: 0.7, 
        metalness: 0.1,  
    });
    bodyGeo.scale(1.1, 1.0, 1.0); 

    bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
    bodyMesh.castShadow = true;
    bodyMesh.receiveShadow = true;
    bodyMesh.userData = { isFace: true };
    sealGroup.add(bodyMesh);

    const posAttribute = bodyGeo.attributes.position;
    const vertex = new THREE.Vector3();
    
    for (let i = 0; i < posAttribute.count; i++) {
        vertex.set(posAttribute.getX(i), posAttribute.getY(i), posAttribute.getZ(i));
        originalPositions.push(vertex.clone());
        velocities.push(new THREE.Vector3(0, 0, 0));

        if (vertex.z > 2.0 && Math.abs(vertex.x) < 0.8 && Math.abs(vertex.y) < 0.8) {
            faceCenterIndices.push(i);
        }
    }

    // --- 2. 目 ---
    function createEyeGroup(x, y, z, side) {
        const group = new THREE.Group();
        group.position.set(x, y, z);
        
        // 2-1. 白目
        const eyeRadius = 0.7;
        const eyeGeo = new THREE.SphereGeometry(eyeRadius, 64, 64);
        eyeGeo.scale(1, 1, 0.6); 
        const eyeMat = new THREE.MeshBasicMaterial({ color: CONFIG.color.eyeWhite });
        const eyeball = new THREE.Mesh(eyeGeo, eyeMat);
        eyeball.userData = { isEye: true, side: side };
        group.add(eyeball);

        // 2-2. 黒目 (修正: さらに薄く、奥へ)
        const pupilGeo = new THREE.SphereGeometry(0.20, 32, 32);
        // 厚みを0.3 -> 0.15 に削減
        pupilGeo.scale(1, 1, 0.15); 
        const pupilMat = new THREE.MeshBasicMaterial({ color: CONFIG.color.pupil });
        const pupil = new THREE.Mesh(pupilGeo, pupilMat);
        // 位置を0.42 -> 0.405 (白目表面ギリギリ)へ後退
        pupil.position.z = 0.405; 
        pupil.userData = { isEye: true, side: side }; 
        group.add(pupil);

        // 2-3. まぶた (修正: わずかに厚みを戻して黒目をカバー)
        const eyelidRadius = 0.701; 
        const eyelidGeo = new THREE.SphereGeometry(eyelidRadius, 64, 64);
        // 厚み: 0.68 -> 0.7 (黒目先端より確実に前に来るように)
        eyelidGeo.scale(1, 1, 0.7);

        const eyelidMat = new THREE.MeshStandardMaterial({
            color: CONFIG.color.body,
            roughness: 0.7,
            metalness: 0.1,
            transparent: false,
            side: THREE.FrontSide
        });

        eyelidMat.onBeforeCompile = (shader) => {
            shader.uniforms.uBlink = { value: 0.0 };
            eyelidMat.userData.shader = shader;

            shader.vertexShader = `
                varying vec3 vLocalPosition;
                ${shader.vertexShader}
            `.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                vLocalPosition = position;
                `
            );

            shader.fragmentShader = `
                uniform float uBlink;
                varying vec3 vLocalPosition;
                ${shader.fragmentShader}
            `.replace(
                '#include <dithering_fragment>',
                `
                #include <dithering_fragment>
                
                // まばたきロジック
                float limit = 0.705;
                float threshold = limit - (uBlink * limit * 2.0);

                if (vLocalPosition.y < threshold && vLocalPosition.y > -threshold) {
                    discard;
                }
                `
            );
        };

        const eyelid = new THREE.Mesh(eyelidGeo, eyelidMat);
        eyelid.userData = { isEye: true, side: side }; 
        eyelid.renderOrder = 2; // 最前面

        group.add(eyelid);

        return { group, pupil, eyelid };
    }

    eyes.left = createEyeGroup(-0.85, 0.4, 2.05, 'left');
    sealGroup.add(eyes.left.group);

    eyes.right = createEyeGroup(0.85, 0.4, 2.05, 'right');
    sealGroup.add(eyes.right.group);
    
    // -----------------------

    // 4. マズルと鼻
    snoutGroup = new THREE.Group();
    sealGroup.add(snoutGroup);
    
    const muzzleGeo = new THREE.SphereGeometry(0.5, 32, 32);
    muzzleGeo.scale(1.2, 0.8, 0.5);
    const muzzleMat = new THREE.MeshStandardMaterial({ 
        color: 0xEEEEEE, 
        roughness: 0.9,
        metalness: 0.0
    });
    
    const muzzleLeft = new THREE.Mesh(muzzleGeo, muzzleMat);
    muzzleLeft.position.set(-0.35, -0.3, 2.4);
    muzzleLeft.rotation.set(0, -0.2, 0.2);
    snoutGroup.add(muzzleLeft);

    const muzzleRight = new THREE.Mesh(muzzleGeo, muzzleMat);
    muzzleRight.position.set(0.35, -0.3, 2.4);
    muzzleRight.rotation.set(0, 0.2, -0.2);
    snoutGroup.add(muzzleRight);

    // 鼻
    const noseGeo = new THREE.SphereGeometry(0.2, 32, 32);
    noseGeo.scale(1, 0.7, 1);
    const noseMat = new THREE.MeshStandardMaterial({ 
        color: CONFIG.color.nose, 
        roughness: 0.5,
        metalness: 0.0
    });
    const nose = new THREE.Mesh(noseGeo, noseMat);
    nose.position.set(0, -0.1, 2.65);
    nose.rotation.x = 0.2;
    nose.userData = { isFace: true }; 
    snoutGroup.add(nose);

    // 5. ヒゲ
    const whiskerMat = new THREE.LineBasicMaterial({ color: 0x333333 });
    const whiskerGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0.8, 0, 0)
    ]);
    const addWhisker = (x, y, z, rz, ry) => {
        const whisker = new THREE.Line(whiskerGeo, whiskerMat);
        whisker.position.set(x, y, z);
        whisker.rotation.z = rz;
        whisker.rotation.y = ry;
        snoutGroup.add(whisker);
    };
    addWhisker(0.6, -0.3, 2.5, 0.1, 0.3);
    addWhisker(0.65, -0.4, 2.45, 0.0, 0.3);
    addWhisker(-0.6, -0.3, 2.5, 3.0, -0.3);
    addWhisker(-0.65, -0.4, 2.45, 3.1, -0.3);

    // 6. 舌
    const tongueRadius = 0.22;
    const tongueGeo = new THREE.SphereGeometry(tongueRadius, 16, 16);
    tongueGeo.scale(1, 0.4, 1.0); 
    tongueGeo.translate(0, 0, tongueRadius);

    const tongueMat = new THREE.MeshStandardMaterial({ 
        color: CONFIG.color.tongue,
        roughness: 0.4,
        metalness: 0.0
    });
    tongue = new THREE.Mesh(tongueGeo, tongueMat);
    tongue.position.set(0, -0.65, 2.25); 
    tongue.userData = { isTongue: true };
    tongue.visible = true; 
    sealGroup.add(tongue);


    partsInitialPos.eyesLeft.copy(eyes.left.group.position);
    partsInitialPos.eyesRight.copy(eyes.right.group.position);
    partsInitialPos.snout.copy(snoutGroup.position);
    partsInitialPos.tongue.copy(tongue.position);
    
    const initialDir = new THREE.Vector3(0, -0.2, 1).normalize(); 
    const initialLen = 0.2; 
    tongueTipPos.copy(partsInitialPos.tongue).add(initialDir.multiplyScalar(initialLen));
}

/**
 * アニメーションループ
 */
function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.001;

    // --- 1. 顔の物理演算 ---
    let localDragPoint = null;
    if (isDraggingFace) {
        localDragPoint = dragPoint.clone().applyMatrix4(bodyMesh.matrixWorld.invert());
    }

    const positionAttribute = bodyMesh.geometry.attributes.position;
    let needsUpdate = false;
    let faceDeformation = new THREE.Vector3(0, 0, 0);
    let deformationCount = 0;

    for (let i = 0; i < originalPositions.length; i++) {
        const original = originalPositions[i];
        const current = new THREE.Vector3(
            positionAttribute.getX(i),
            positionAttribute.getY(i),
            positionAttribute.getZ(i)
        );

        let force = new THREE.Vector3(0, 0, 0);
        
        const displacement = new THREE.Vector3().subVectors(original, current);
        force.add(displacement.multiplyScalar(CONFIG.physics.springStrength));

        if (isDraggingFace && !isDraggingTongue && localDragPoint) {
            const dist = original.distanceTo(localDragPoint);
            if (dist < CONFIG.physics.radius) {
                const t = dist / CONFIG.physics.radius;
                const influence = (Math.cos(t * Math.PI) + 1.0) * 0.5;
                const pullStrength = 0.06; 
                const pull = new THREE.Vector3().subVectors(localDragPoint, original).multiplyScalar(influence * pullStrength);
                force.add(pull);
            }
        }

        velocities[i].add(force);
        velocities[i].multiplyScalar(CONFIG.physics.damping);
        current.add(velocities[i]);

        const diff = new THREE.Vector3().subVectors(current, original);
        if (diff.length() > CONFIG.physics.maxDeformation) {
            diff.normalize().multiplyScalar(CONFIG.physics.maxDeformation);
            current.lerp(original.clone().add(diff), 0.2);
            velocities[i].multiplyScalar(0.5);
        }

        positionAttribute.setXYZ(i, current.x, current.y, current.z);
        if (velocities[i].lengthSq() > 0.0001) needsUpdate = true;
    }

    if (needsUpdate || isDraggingFace) {
        positionAttribute.needsUpdate = true;
        bodyMesh.geometry.computeVertexNormals();
    }

    // --- 2. パーツ追従 ---
    for (let idx of faceCenterIndices) {
        const original = originalPositions[idx];
        const currentX = positionAttribute.getX(idx);
        const currentY = positionAttribute.getY(idx);
        const currentZ = positionAttribute.getZ(idx);
        faceDeformation.x += currentX - original.x;
        faceDeformation.y += currentY - original.y;
        faceDeformation.z += currentZ - original.z;
        deformationCount++;
    }
    if (deformationCount > 0) faceDeformation.divideScalar(deformationCount);

    eyes.left.group.position.copy(partsInitialPos.eyesLeft).add(faceDeformation);
    eyes.right.group.position.copy(partsInitialPos.eyesRight).add(faceDeformation);
    snoutGroup.position.copy(partsInitialPos.snout).add(faceDeformation);
    
    // --- 3. 360度回転処理 ---
    const speed = spinVelocity.length();
    if (speed > 0.001) {
        isSpinning = true;
        const axis = spinVelocity.clone().normalize();
        const angle = speed;
        const deltaQ = new THREE.Quaternion();
        deltaQ.setFromAxisAngle(axis, angle);
        sealGroup.quaternion.premultiply(deltaQ);
        spinVelocity.multiplyScalar(CONFIG.interaction.friction);
    } else {
        isSpinning = false;
        if (!isDraggingFace && !isDraggingTongue && !isHoldingBg) {
            const targetQ = new THREE.Quaternion(); 
            sealGroup.quaternion.slerp(targetQ, CONFIG.interaction.recoverySpeed);
        }
    }

    // --- 4. ベロの物理演算 ---
    const tongueRootPos = partsInitialPos.tongue.clone().add(faceDeformation);
    let targetTipPos = new THREE.Vector3();
    const restDir = new THREE.Vector3(0, -0.2, 1).normalize(); 
    
    if (isDraggingTongue) {
        let localDrag = dragPoint.clone().applyMatrix4(sealGroup.matrixWorld.invert());
        targetTipPos.copy(localDrag);

        const dist = targetTipPos.distanceTo(tongueRootPos);
        const maxLen = 3.5; 
        if (dist > maxLen) {
            const dir = new THREE.Vector3().subVectors(targetTipPos, tongueRootPos).normalize();
            targetTipPos.copy(tongueRootPos).add(dir.multiplyScalar(maxLen));
        }
        tongueTipPos.lerp(targetTipPos, 0.2);
        tongueTipVelocity.set(0, 0, 0);

    } else {
        let targetLen = 0.15; 
        if (tongueAnimState === 0 && Math.random() < 0.005 && !isSpinning && !isHoldingBg) {
            tongueAnimState = 1; 
        }

        if (tongueAnimState === 1) { 
            targetLen = 0.6; 
            const currentLen = tongueTipPos.distanceTo(tongueRootPos);
            if (currentLen > 0.55) tongueAnimState = 2;
        } else if (tongueAnimState === 2) { 
            targetLen = 0.15;
            const currentLen = tongueTipPos.distanceTo(tongueRootPos);
            if (currentLen < 0.2) tongueAnimState = 0;
        }

        targetTipPos.copy(tongueRootPos).add(restDir.multiplyScalar(targetLen));

        const force = new THREE.Vector3().subVectors(targetTipPos, tongueTipPos).multiplyScalar(0.15);
        tongueTipVelocity.add(force);
        tongueTipVelocity.multiplyScalar(0.75); 
        tongueTipPos.add(tongueTipVelocity);
    }

    tongue.position.copy(tongueRootPos);
    tongue.lookAt(tongueTipPos);

    const currentDist = tongueRootPos.distanceTo(tongueTipPos);
    const scaleZ = Math.max(0.01, currentDist / TONGUE_BASE_LEN);
    const thinning = Math.max(0.6, 1.0 - (scaleZ - 1.0) * 0.1); 
    tongue.scale.set(thinning, 0.4 * thinning, scaleZ);


    // --- 5. 視線とまばたきの制御 ---
    const isFastSpinning = spinVelocity.length() > 0.15;
    
    // まばたきアニメーション (Shader Uniform更新)
    ['left', 'right'].forEach(side => {
        const diff = targetBlinkState[side] - blinkState[side];
        blinkState[side] += diff * CONFIG.interaction.blinkSpeed;
        
        if (eyes[side].eyelid && eyes[side].eyelid.material.userData.shader) {
            eyes[side].eyelid.material.userData.shader.uniforms.uBlink.value = blinkState[side];
        }
    });


    // 視線（黒目）の移動
    if (isFastSpinning) {
        eyes.left.pupil.position.set(0.2, Math.sin(time * 20) * 0.1, 0.405);
        eyes.right.pupil.position.set(-0.2, -Math.sin(time * 20) * 0.1, 0.405);
    } else {
        let targetX = 0;
        let targetY = 0;
        if ((isDraggingFace || isDraggingTongue || isHoldingBg) && !isTouchingEye) {
            targetX = mouse.x * 0.3;
            targetY = mouse.y * 0.3;
        }
        
        const pLeft = eyes.left.pupil.position;
        const pRight = eyes.right.pupil.position;
        
        pLeft.x += (targetX - pLeft.x) * 0.2;
        pLeft.y += (targetY - pLeft.y) * 0.2;
        pRight.x += (targetX - pRight.x) * 0.2;
        pRight.y += (targetY - pRight.y) * 0.2;
    }

    renderer.render(scene, camera);
}

/**
 * イベントハンドラ
 */
function onPointerDown(event) {
    updateMouse(event);
    lastMousePos.set(event.clientX, event.clientY);
    dragVelocity.set(0, 0);

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    
    const hitTongue = intersects.find(hit => hit.object.userData.isTongue);
    const hitEye = intersects.find(hit => hit.object.userData.isEye); 
    const hitFace = intersects.find(hit => hit.object.userData.isFace);

    if (hitTongue) {
        isDraggingTongue = true;
        isDraggingFace = false;
        isTouchingEye = false;
        dragPoint.copy(hitTongue.point);
    } else if (hitEye) {
        isDraggingTongue = false;
        isDraggingFace = false;
        isTouchingEye = true;
        
        if (hitEye.object.userData.side === 'left') targetBlinkState.left = 1;
        if (hitEye.object.userData.side === 'right') targetBlinkState.right = 1;

    } else if (hitFace) {
        isDraggingFace = true;
        isDraggingTongue = false;
        isTouchingEye = false;
        dragPoint.copy(hitFace.point);
        targetBlinkState.left = 0;
        targetBlinkState.right = 0;

    } else {
        isHoldingBg = true;
        spinVelocity.set(0, 0, 0);
        targetBlinkState.left = 0;
        targetBlinkState.right = 0;
    }
}

function onPointerMove(event) {
    updateMouse(event);
    const currentPos = new THREE.Vector2(event.clientX, event.clientY);
    dragVelocity.subVectors(currentPos, lastMousePos);
    lastMousePos.copy(currentPos);

    raycaster.setFromCamera(mouse, camera);

    if (isDraggingFace || isDraggingTongue) {
        const targetZ = 2.5; 
        const vec = new THREE.Vector3();
        vec.set(mouse.x, mouse.y, 0.5);
        vec.unproject(camera);
        vec.sub(camera.position).normalize();
        const distance = (targetZ - camera.position.z) / vec.z;
        const pos = new THREE.Vector3().copy(camera.position).add(vec.multiplyScalar(distance));
        dragPoint.copy(pos);
    }
}

function onPointerUp(event) {
    if (isDraggingTongue) {
        const dx = tongueTipPos.x - tongue.position.x;
        const dy = tongueTipPos.y - tongue.position.y;
        const pullLen = Math.sqrt(dx*dx + dy*dy);
        
        if (pullLen > 0.3) {
            const axisX = dy * CONFIG.interaction.recoilFactor * 0.1; 
            const axisY = -dx * CONFIG.interaction.recoilFactor * 0.1;
            spinVelocity.x += axisX;
            spinVelocity.y += axisY;
        }
    }

    if (isHoldingBg) {
        const speed = dragVelocity.length();
        if (speed > CONFIG.interaction.spinThreshold) {
            const axisX = dragVelocity.y * 0.01;
            const axisY = dragVelocity.x * 0.01;
            spinVelocity.x += axisX;
            spinVelocity.y += axisY;
        }
    }

    isDraggingFace = false;
    isDraggingTongue = false;
    isHoldingBg = false;
    isTouchingEye = false;

    targetBlinkState.left = 0;
    targetBlinkState.right = 0;
}

function updateMouse(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

init();

</script>
</body>
</html>